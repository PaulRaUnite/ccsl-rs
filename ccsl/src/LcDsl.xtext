// automatically generated by Xtext
grammar fr.unice.lightccsl.lcdsl.LcDsl with org.eclipse.xtext.common.Terminals

import "http://www.unice.fr/lightCCSL" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Specification returns GlobalSpecification hidden(WS, SL_COMMENT, ML_COMMENT):
	'Specification'
	name=EString
	( specifications+=SubSpecification )*
	'{'
		'Clock' clocks+=LogicalClock ( (",")? clocks+=LogicalClock)*
		('[' constraints+=Constraint ( constraints+=Constraint )* ']' )?
	'}';

SubSpecification returns SubSpecification:
	'def' name=EString 
	'(' ( ('Clock' clocks+=LogicalClock) | ('int' parameters+=Parameter) ) 
	    ( "," (('Clock' clocks+=LogicalClock) | ('int' parameters+=Parameter)) )* ')'
	'['
	  ( 'Clock' localClocks+=LogicalClock (',' localClocks+=LogicalClock )*)? 
	  constraints+=Constraint ( constraints+=Constraint )* 
	']'	
;

Parameter returns Parameter:
	{Parameter}
	name=EString
;

Constraint returns Constraint:
	CausalChain | Periodic | SubClockChain | 
	ExclusionChain | Let | Call;
	
Call returns Call:
	'call' subspecification=[SubSpecification|EString] 
	'(' clocks+=[ALogicalClock|EString] (',' clocks+=[ALogicalClock|EString] )* ')' 
	('(' parameters+=NaturalNumber (',' parameters+=NaturalNumber)* ')' )?
;

Expression returns Expression:
	PrefixExpression | SequenceExpression | Repeat;

EString returns ecore::EString:
	STRING | ID;

LogicalClock returns LogicalClock:
	{LogicalClock}
	name=EString;

CausalChain returns CausalChain:
	'Precedence'
		first=[LogicalClock|EString]
		causalities+=Causality ( causalities+=Causality )* 		
;

ParameterRef returns ParameterRef:
	{ParameterRef}
	parameter=[Parameter|EString] (next=ArithmeticExpression)?
;

ArithmeticExpression returns Arithmetic:
	operator=ArithmeticOperator value=FiniteNaturalNumber
;
IntNaturalNumber returns IntNaturalNumber:
	value=EInt
;
FiniteNaturalNumber returns NaturalNumber:
	IntNaturalNumber | ParameterRef
;
Infinity returns Infinity:
	{Infinity} 'Infinity' | 
	{Infinity} '\u221E'
;
NaturalNumber returns NaturalNumber:
	Infinity | FiniteNaturalNumber
;
Repeat returns Repeat:
	Every | Sample | Delay | Slice
;
Every returns Repeat:
	'every' (period=FiniteNaturalNumber)? ref=[LogicalClock|EString]
	('from' from=FiniteNaturalNumber)?
	('upTo' upTo=NaturalNumber)?
;
Sample returns Repeat:
	ref=[LogicalClock|EString] 'sampledOn' base=[LogicalClock|EString]
;
Delay returns Repeat:
	ref=[LogicalClock|EString] ('$' | 'delay' 'for') from=FiniteNaturalNumber ( 'on'? base=[LogicalClock|EString] )?
;
Slice returns Repeat:
	ref=[LogicalClock|EString] '[' from=FiniteNaturalNumber ',' upTo=NaturalNumber ']'
;
Periodic returns Periodic:
	('repeat' definedClock=LogicalClock repeat=Every ) |
	(definedClock=LogicalClock '=' repeat=Delay) |
	(definedClock=LogicalClock '=' repeat=Sample) |
	(definedClock=LogicalClock '=' repeat=Slice )
;

SubClockChain returns SubClockChain:
	'SubClocking'
		superClocks+=[LogicalClock|EString] ( "<-" superClocks+=[LogicalClock|EString] )* 
	;

ExclusionChain returns ExclusionChain:
	'Exclusion'
		clocks+=[LogicalClock|EString] ( "#" clocks+=[LogicalClock|EString] )+ 
	;

Let returns Let:
	'Let' definedClock=LogicalClock
		'be' definition=Expression 
	;

Causality returns Causality:
	kind=CausalKind ('(' ('init:' init=FiniteNaturalNumber)? ('max:' max=NaturalNumber)? ')')?
	clock=[LogicalClock|EString]
;

enum CausalKind returns CausalKind:
	strict = '<' | loose = '<=';

EInt returns ecore::EInt:
	'-'? INT;

PrefixExpression returns PrefixExpression:
	kind=ExpressionKind
	'(' refClocks+=[LogicalClock|EString] ( "," refClocks+=[LogicalClock|EString])* ')' 
	;

SequenceExpression returns SequenceExpression:
	firstClock=[LogicalClock|EString]
	( subExpressions+=SubExpression)*
;

SubExpression returns SubExpression:
	ExpressionRef | ClockRef;
	
ExpressionRef returns ExpressionRef:
	op=Operator '(' expression=Expression ')'
;
ClockRef returns ClockRef:
	op=Operator clock=[LogicalClock|EString];

enum ExpressionKind returns ExpressionKind:
				inf = 'inf' | sup = 'sup';

enum Operator returns Operator:
				union = '+' | union = 'or' |
				intersection = '*' | intersection = 'and' |
				minus = '-' | minus = 'minus' |
				nor='nor' | nand = 'nand';
				
enum ArithmeticOperator returns ArithmeticOperator:
	ADD = '+' | MINUS = '-' | MULT = "*" | DIV = "/" | MODULO = "%"
;
				